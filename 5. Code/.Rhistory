storage.mode(tedRate) <- "numeric"
tedRate2 = lag(tedRate, k=1, na.pad =FALSE)
merge(tedRate, tedRate2, all=TRUE, fill = NA)
#
#
#         Part 2: Logistical Regression
#
#
# Naive Bayes or Logistical Regression
length(tedRate)
tedRateEvolution = tedRate
i=1
# Creating the binary data. 1 if increase, 0 if decrease or stay the same
for (i in 1:length(tedRate)){
# a = coredata(tedRate[i+1,])
# b = coredata(tedRate[i,])
if (i==length(tedRate)) {
tedRateEvolution[i, ] = NA
} else if(is.na(tedRate[i+1, ]) || is.na(tedRate[i, ])){
tedRateEvolution[i, ] = NA
} else if(coredata(tedRate[i+1, ]) > coredata(tedRate[i, ])){
tedRateEvolution[i, ] = 1
} else {
tedRateEvolution[i, ] = 0
}
}
tedRateEvolution
tedRate2
dependentVariables = tedRate2
dependentVariables
size(tedRate2)
ncol(tedRate2)
weightvector = (randomWeight,
nrow = ncol(dependentVariables)+1, # we Create a weight for each dependent variable, plus one for w0.
ncol= 0 ,
byrow = TRUE
)
randomWeight=0
dependentVariables = tedRate2
weightvector = (randomWeight,
nrow = ncol(dependentVariables)+1, # we Create a weight for each dependent variable, plus one for w0.
ncol= 0 ,
byrow = TRUE
)
weightvector = (NA,
nrow = ncol(dependentVariables)+1, # we Create a weight for each dependent variable, plus one for w0.
ncol= 0,
byrow = TRUE
)
weightvector = (NA,
nrow = ncol(dependentVariables)+1, # we Create a weight for each dependent variable, plus one for w0.
ncol= 0,
byrow = TRUE
)
ncol(dependentVariables)+1
nrow = ncol(dependentVariables)+1
(NA,
nrow = ncol(dependentVariables)+1, # we Create a weight for each dependent variable, plus one for w0.
ncol= 0,
byrow = TRUE
)
weightvector = matrix(NA,
nrow = ncol(dependentVariables)+1, # we Create a weight for each dependent variable, plus one for w0.
ncol= 0,
byrow = TRUE
)
weightvector
weightvector = matrix(NA,
nrow = ncol(dependentVariables)+1, # we Create a weight for each dependent variable, plus one for w0.
ncol= 1,
byrow = TRUE
)
weightvector
randomWeight=0
dependentVariables = tedRate2
weightvector = matrix(randomWeight,
nrow = ncol(dependentVariables)+1, # we Create a weight for each dependent variable, plus one for w0.
ncol= 1,
byrow = TRUE
)
weightvector
nrow(weightVector)
weightVector = matrix(randomWeight,
nrow = ncol(dependentVariables)+1, # we Create a weight for each dependent variable, plus one for w0.
ncol= 1,
byrow = TRUE
)
nrow(weightVector)
colnames = matrix("0", nrow = ncol(dependentVariables)+1, ncol= 1, byrow = TRUE)
colnames
for (i in 1:nrow(weightVector)) {
colnames[i, ] = "w_"&i
)
}
colnames = matrix("0", nrow = ncol(dependentVariables)+1, ncol= 1, byrow = TRUE)
for (i in 1:nrow(weightVector)) {
colnames[i, ] = "w_" & i
)
}
for (i in 1:nrow(weightVector)) {
colnames[i, ] = "w_" & i
}
sprintf("w_" & i)
sprintf("w_", i)
colnames[i, ] = sprintf("w_", i)
colnames
colnames[i, ] = sprintf("w_", i-1)
colnames
colnames[i, ] = paste("w_", i-1)
colnames
colnames = matrix("0", nrow = ncol(dependentVariables)+1, ncol= 1, byrow = TRUE)
for (i in 1:nrow(weightVector)) {
colnames[i, ] = paste("w_", i-1)
}
colnames
colnames = matrix("0", nrow = ncol(dependentVariables)+1, ncol= 1, byrow = TRUE)
for (i in 1:nrow(weightVector)) {
colnames[i, ] = paste("w_",i-1)
}
colnames
colnames[i, ] = paste("w_", i-1, sep="")
colnames
colnames = matrix("0", nrow = ncol(dependentVariables)+1, ncol= 1, byrow = TRUE)
for (i in 1:nrow(weightVector)) {
colnames[i, ] = paste("w_", i-1, sep="")
}
colnames = matrix("0", nrow = ncol(dependentVariables)+1, ncol= 1, byrow = TRUE)
for (i in 1:nrow(weightVector)) {
colnames[i, ] = paste("w", i-1, sep="")
}
colnames
colnames(colNames)
colNames = matrix("0", nrow = ncol(dependentVariables)+1, ncol= 1, byrow = TRUE)
for (i in 1:nrow(weightVector)) {
colNames[i, ] = paste("w", i-1, sep="")
}
colnames(colNames)
colNames
colnames(weightVector)= colNames
for (i in 1:nrow(weightVector)) {
colnames(weightVector[i, ])= colNames[i,]
}
weightVector
colnames(weightVector) = c("c1","c2")
for (i in 1:nrow(weightVector)) {
rownames(weightVector[i, ])= colNames[i,]
}
rowname(weightVector[i, ])= colNames[i,]
rownames(weightVector[i, ])= colNames[i,]
weightvector
row.names(weightVector[i, ])= colNames[i,]
colNames[1,]
weightVector[1,]
library(xts)
library(zoo)
#
#
#         Part 1: Creating the dataFrame
#
#
# Opening the data
csvFilePathTedRate = "/Users/Michal/Dropbox/UNISG/16. Research Seminar/4. Data/TED Spread.csv"
tedRate = read.csv(file=csvFilePathTedRate, header=TRUE, sep=",")
# Replaces all "." as "NA"
tedRate[tedRate == "."] <- NA
# Creates a sequence of dates
startingDate = "2000-01-01"
endDate = "2018-03-05"
dates = seq(as.Date(startingDate), as.Date(endDate), by=1)
# OPTIONAL: Truncating the size for testing
tedRate = tedRate[1:20, c('DATE', 'TEDRATE')]
dates = dates[1:29]
# Create a Timeseries of tedRate indexed by date
tedRate$DATE = as.Date(tedRate$DATE, format="%Y-%m-%d")
tedRate = xts(tedRate[,2], order.by = tedRate$DATE)
#Converts the data into numeric value (somehow xts automatically converts it into characters)
storage.mode(tedRate) <- "numeric"
tedRate2 = lag(tedRate, k=1, na.pad =FALSE)
merge(tedRate, tedRate2, all=TRUE, fill = NA)
#
#
#         Part 2: Data Manipulation
#
#
length(tedRate)
tedRateEvolution = tedRate
i=1
# Creates "tedRateEvolution", it's a vector with binary data (1 if the value increases at t+1, and 0 otherwise).
for (i in 1:length(tedRate)) {
if (i==length(tedRate)) { # When we get to the last data entry, the output is always NA because we cannot compare it to a future value. Without this, there is an error message
tedRateEvolution[i, ] = NA
} else if (is.na(tedRate[i+1, ]) || is.na(tedRate[i, ])) { # If comparing with a NA, the output is automatically NA.
tedRateEvolution[i, ] = NA
} else if (coredata(tedRate[i+1, ]) > coredata(tedRate[i, ])) {
tedRateEvolution[i, ] = 1
} else {
tedRateEvolution[i, ] = 0
}
}
# https://www.youtube.com/watch?v=Z5WKQr4H4Xk --> source in youtube
# note: one issue of the logistical regression is that we don't know the tail risk (i.e. if there is 96% chance the value will be positive, we do not know how negative it could be in the 4%)
#
#
#         Part 3: Logistical Regression
#
#
# Creating the weight vector
randomWeight=0 # note: we can randomize this vector later on
dependentVariables = tedRate2
weightVector = matrix(randomWeight,
nrow = ncol(dependentVariables)+1, # we Create a weight for each dependent variable, plus one for w0.
ncol= 1,
byrow = TRUE
)
# Giving names to rows in weightVector
rowNames = matrix("0", nrow = ncol(dependentVariables)+1, ncol= 1, byrow = TRUE)
for (i in 1:nrow(weightVector)) {
rowNames[i, ] = paste("w", i-1, sep="")
}
for (i in 1:nrow(weightVector)) {
row.names(weightVector[i, ])= rowNames[i,]
}
c(rowNames)
rownames(weightVector)=c(rowNames)
weightVector
rowNames = matrix("0", nrow = ncol(dependentVariables)+1, ncol= 1, byrow = TRUE)
for (i in 1:nrow(weightVector)) {
rowNames[i, ] = paste("w", i-1, sep="")
}
rownames(weightVector)=c(rowNames)
randomWeight=0 # note: we can randomize this vector later on
dependentVariables = tedRate2
weightVector = matrix(randomWeight,
nrow = ncol(dependentVariables)+1, # we Create a weight for each dependent variable, plus one for w0.
ncol= 1,
byrow = TRUE
)
rowNames = matrix("0", nrow = ncol(dependentVariables)+1, ncol= 1, byrow = TRUE)
for (i in 1:nrow(weightVector)) {
rowNames[i, ] = paste("w", i-1, sep="")
}
rownames(weightVector)=c(rowNames)
weightVector
par.est0.5
vcov()
modelOLS
#Problem 2 - Task 1
########################################################################################
#simulate a dgp based on bivariate regression model
#y = 0.3 + 0.6x + u
# set random seed for simulation and the number of repetitions
set.seed(15647)
reps=1000
#I create an empty matrix to store simulation results and set the values for b0, b1 and n
par.est0=matrix(NA,nrow=reps,ncol=4)
par.est0.1=matrix(NA,nrow=reps,ncol=4)
par.est0.2=matrix(NA,nrow=reps,ncol=4)
par.est0.3=matrix(NA,nrow=reps,ncol=4)
par.est0.4=matrix(NA,nrow=reps,ncol=4)
par.est0.5=matrix(NA,nrow=reps,ncol=4)
par.est0.6=matrix(NA,nrow=reps,ncol=4)
par.est0.7=matrix(NA,nrow=reps,ncol=4)
par.est0.8=matrix(NA,nrow=reps,ncol=4)
par.est0.9=matrix(NA,nrow=reps,ncol=4)
par.est1=matrix(NA,nrow=reps,ncol=4)
b0=0.3
b1=0.6
n=1000
# draw independent variable from uniform distributuion
# on interval [-1,1]
X=runif(n,-1,1)
for(i in 1:reps){ # start loop
Y=b0+b1*X+rnorm(n,mean=0,sd=0) # true dgp with standard normal errors
modelOLS=lm(Y~X) # estimate ols model
vcv=vcov(modelOLS) # obtain estimated variance-covariance matrix
par.est0[i,1]=modelOLS$coef[1] # store estimate of b0
par.est0[i,2]=modelOLS$coef[2] # store estimate of b1
par.est0[i,3]=sqrt(diag(vcv)[1]) # store estimated standard error of b0
par.est0[i,4]=sqrt(diag(vcv)[2]) # store estimated standard error of b1
} # close loop
for(i in 1:reps){ # start loop
Y=b0+b1*X+rnorm(n,mean=0,sd=0.1) # true dgp with standard normal errors
modelOLS=lm(Y~X) # estimate ols model
vcv=vcov(modelOLS) # obtain estimated variance-covariance matrix
par.est0.1[i,1]=modelOLS$coef[1] # store estimate of b0
par.est0.1[i,2]=modelOLS$coef[2] # store estimate of b1
par.est0.1[i,3]=sqrt(diag(vcv)[1]) # store estimated standard error of b0
par.est0.1[i,4]=sqrt(diag(vcv)[2]) # store estimated standard error of b1
} # close loop
for(i in 1:reps){ # start loop
Y=b0+b1*X+rnorm(n,mean=0,sd=0.2) # true dgp with standard normal errors
modelOLS=lm(Y~X) # estimate ols model
vcv=vcov(modelOLS) # obtain estimated variance-covariance matrix
par.est0.2[i,1]=modelOLS$coef[1] # store estimate of b0
par.est0.2[i,2]=modelOLS$coef[2] # store estimate of b1
par.est0.2[i,3]=sqrt(diag(vcv)[1]) # store estimated standard error of b0
par.est0.2[i,4]=sqrt(diag(vcv)[2]) # store estimated standard error of b1
} # close loop
for(i in 1:reps){ # start loop
Y=b0+b1*X+rnorm(n,mean=0,sd=0.3) # true dgp with standard normal errors
modelOLS=lm(Y~X) # estimate ols model
vcv=vcov(modelOLS) # obtain estimated variance-covariance matrix
par.est0.3[i,1]=modelOLS$coef[1] # store estimate of b0
par.est0.3[i,2]=modelOLS$coef[2] # store estimate of b1
par.est0.3[i,3]=sqrt(diag(vcv)[1]) # store estimated standard error of b0
par.est0.3[i,4]=sqrt(diag(vcv)[2]) # store estimated standard error of b1
} # close loop
for(i in 1:reps){ # start loop
Y=b0+b1*X+rnorm(n,mean=0,sd=0.4) # true dgp with standard normal errors
modelOLS=lm(Y~X) # estimate ols model
vcv=vcov(modelOLS) # obtain estimated variance-covariance matrix
par.est0.4[i,1]=modelOLS$coef[1] # store estimate of b0
par.est0.4[i,2]=modelOLS$coef[2] # store estimate of b1
par.est0.4[i,3]=sqrt(diag(vcv)[1]) # store estimated standard error of b0
par.est0.4[i,4]=sqrt(diag(vcv)[2]) # store estimated standard error of b1
} # close loop
for(i in 1:reps){ # start loop
Y=b0+b1*X+rnorm(n,mean=0,sd=0.5) # true dgp with standard normal errors
modelOLS=lm(Y~X) # estimate ols model
vcv=vcov(modelOLS) # obtain estimated variance-covariance matrix
par.est0.5[i,1]=modelOLS$coef[1] # store estimate of b0
par.est0.5[i,2]=modelOLS$coef[2] # store estimate of b1
par.est0.5[i,3]=sqrt(diag(vcv)[1]) # store estimated standard error of b0
par.est0.5[i,4]=sqrt(diag(vcv)[2]) # store estimated standard error of b1
} # close loop
for(i in 1:reps){ # start loop
Y=b0+b1*X+rnorm(n,mean=0,sd=0.6) # true dgp with standard normal errors
modelOLS=lm(Y~X) # estimate ols model
vcv=vcov(modelOLS) # obtain estimated variance-covariance matrix
par.est0.6[i,1]=modelOLS$coef[1] # store estimate of b0
par.est0.6[i,2]=modelOLS$coef[2] # store estimate of b1
par.est0.6[i,3]=sqrt(diag(vcv)[1]) # store estimated standard error of b0
par.est0.6[i,4]=sqrt(diag(vcv)[2]) # store estimated standard error of b1
} # close loop
for(i in 1:reps){ # start loop
Y=b0+b1*X+rnorm(n,mean=0,sd=0.7) # true dgp with standard normal errors
modelOLS=lm(Y~X) # estimate ols model
vcv=vcov(modelOLS) # obtain estimated variance-covariance matrix
par.est0.7[i,1]=modelOLS$coef[1] # store estimate of b0
par.est0.7[i,2]=modelOLS$coef[2] # store estimate of b1
par.est0.7[i,3]=sqrt(diag(vcv)[1]) # store estimated standard error of b0
par.est0.7[i,4]=sqrt(diag(vcv)[2]) # store estimated standard error of b1
} # close loop
for(i in 1:reps){ # start loop
Y=b0+b1*X+rnorm(n,mean=0,sd=0.8) # true dgp with standard normal errors
modelOLS=lm(Y~X) # estimate ols model
vcv=vcov(modelOLS) # obtain estimated variance-covariance matrix
par.est0.8[i,1]=modelOLS$coef[1] # store estimate of b0
par.est0.8[i,2]=modelOLS$coef[2] # store estimate of b1
par.est0.8[i,3]=sqrt(diag(vcv)[1]) # store estimated standard error of b0
par.est0.8[i,4]=sqrt(diag(vcv)[2]) # store estimated standard error of b1
} # close loop
for(i in 1:reps){ # start loop
Y=b0+b1*X+rnorm(n,mean=0,sd=0.9) # true dgp with standard normal errors
modelOLS=lm(Y~X) # estimate ols model
vcv=vcov(modelOLS) # obtain estimated variance-covariance matrix
par.est0.9[i,1]=modelOLS$coef[1] # store estimate of b0
par.est0.9[i,2]=modelOLS$coef[2] # store estimate of b1
par.est0.9[i,3]=sqrt(diag(vcv)[1]) # store estimated standard error of b0
par.est0.9[i,4]=sqrt(diag(vcv)[2]) # store estimated standard error of b1
} # close loop
for(i in 1:reps){ # start loop
Y=b0+b1*X+rnorm(n,mean=0,sd=1)
modelOLS=lm(Y~X) # estimate ols model
vcv=vcov(modelOLS) # obtain estimated variance-covariance matrix
par.est1[i,1]=modelOLS$coef[1]
par.est1[i,2]=modelOLS$coef[2]
par.est1[i,3]=sqrt(diag(vcv)[1])
par.est1[i,4]=sqrt(diag(vcv)[2])
} # close loop
plot(par.est0[,2],par.est1[,2],col="darkred")
modelOLS
modelOLS
View(par.est0.2)
par.est0
modelOLS
#Problem 2 - Task 1
########################################################################################
#simulate a dgp based on bivariate regression model
#y = 0.3 + 0.6x + u
# set random seed for simulation and the number of repetitions
set.seed(15647)
reps=1000
#I create an empty matrix to store simulation results and set the values for b0, b1 and n
par.est0=matrix(NA,nrow=reps,ncol=4)
par.est0.1=matrix(NA,nrow=reps,ncol=4)
par.est0.2=matrix(NA,nrow=reps,ncol=4)
par.est0.3=matrix(NA,nrow=reps,ncol=4)
par.est0.4=matrix(NA,nrow=reps,ncol=4)
par.est0.5=matrix(NA,nrow=reps,ncol=4)
par.est0.6=matrix(NA,nrow=reps,ncol=4)
par.est0.7=matrix(NA,nrow=reps,ncol=4)
par.est0.8=matrix(NA,nrow=reps,ncol=4)
par.est0.9=matrix(NA,nrow=reps,ncol=4)
par.est1=matrix(NA,nrow=reps,ncol=4)
b0=0.3
b1=0.6
n=1000
# draw independent variable from uniform distributuion
# on interval [-1,1]
X=runif(n,-1,1)
for(i in 1:reps){ # start loop
Y=b0+b1*X+rnorm(n,mean=0,sd=0) # true dgp with standard normal errors
modelOLS1=lm(Y~X) # estimate ols model
vcv=vcov(modelOLS) # obtain estimated variance-covariance matrix
par.est0[i,1]=modelOLS$coef[1] # store estimate of b0
par.est0[i,2]=modelOLS$coef[2] # store estimate of b1
par.est0[i,3]=sqrt(diag(vcv)[1]) # store estimated standard error of b0
par.est0[i,4]=sqrt(diag(vcv)[2]) # store estimated standard error of b1
} # close loop
for(i in 1:reps){ # start loop
Y=b0+b1*X+rnorm(n,mean=0,sd=0.1) # true dgp with standard normal errors
modelOLS=lm(Y~X) # estimate ols model
vcv=vcov(modelOLS) # obtain estimated variance-covariance matrix
par.est0.1[i,1]=modelOLS$coef[1] # store estimate of b0
par.est0.1[i,2]=modelOLS$coef[2] # store estimate of b1
par.est0.1[i,3]=sqrt(diag(vcv)[1]) # store estimated standard error of b0
par.est0.1[i,4]=sqrt(diag(vcv)[2]) # store estimated standard error of b1
} # close loop
for(i in 1:reps){ # start loop
Y=b0+b1*X+rnorm(n,mean=0,sd=0.2) # true dgp with standard normal errors
modelOLS=lm(Y~X) # estimate ols model
vcv=vcov(modelOLS) # obtain estimated variance-covariance matrix
par.est0.2[i,1]=modelOLS$coef[1] # store estimate of b0
par.est0.2[i,2]=modelOLS$coef[2] # store estimate of b1
par.est0.2[i,3]=sqrt(diag(vcv)[1]) # store estimated standard error of b0
par.est0.2[i,4]=sqrt(diag(vcv)[2]) # store estimated standard error of b1
} # close loop
for(i in 1:reps){ # start loop
Y=b0+b1*X+rnorm(n,mean=0,sd=0.3) # true dgp with standard normal errors
modelOLS=lm(Y~X) # estimate ols model
vcv=vcov(modelOLS) # obtain estimated variance-covariance matrix
par.est0.3[i,1]=modelOLS$coef[1] # store estimate of b0
par.est0.3[i,2]=modelOLS$coef[2] # store estimate of b1
par.est0.3[i,3]=sqrt(diag(vcv)[1]) # store estimated standard error of b0
par.est0.3[i,4]=sqrt(diag(vcv)[2]) # store estimated standard error of b1
} # close loop
for(i in 1:reps){ # start loop
Y=b0+b1*X+rnorm(n,mean=0,sd=0.4) # true dgp with standard normal errors
modelOLS=lm(Y~X) # estimate ols model
vcv=vcov(modelOLS) # obtain estimated variance-covariance matrix
par.est0.4[i,1]=modelOLS$coef[1] # store estimate of b0
par.est0.4[i,2]=modelOLS$coef[2] # store estimate of b1
par.est0.4[i,3]=sqrt(diag(vcv)[1]) # store estimated standard error of b0
par.est0.4[i,4]=sqrt(diag(vcv)[2]) # store estimated standard error of b1
} # close loop
for(i in 1:reps){ # start loop
Y=b0+b1*X+rnorm(n,mean=0,sd=0.5) # true dgp with standard normal errors
modelOLS=lm(Y~X) # estimate ols model
vcv=vcov(modelOLS) # obtain estimated variance-covariance matrix
par.est0.5[i,1]=modelOLS$coef[1] # store estimate of b0
par.est0.5[i,2]=modelOLS$coef[2] # store estimate of b1
par.est0.5[i,3]=sqrt(diag(vcv)[1]) # store estimated standard error of b0
par.est0.5[i,4]=sqrt(diag(vcv)[2]) # store estimated standard error of b1
} # close loop
for(i in 1:reps){ # start loop
Y=b0+b1*X+rnorm(n,mean=0,sd=0.6) # true dgp with standard normal errors
modelOLS=lm(Y~X) # estimate ols model
vcv=vcov(modelOLS) # obtain estimated variance-covariance matrix
par.est0.6[i,1]=modelOLS$coef[1] # store estimate of b0
par.est0.6[i,2]=modelOLS$coef[2] # store estimate of b1
par.est0.6[i,3]=sqrt(diag(vcv)[1]) # store estimated standard error of b0
par.est0.6[i,4]=sqrt(diag(vcv)[2]) # store estimated standard error of b1
} # close loop
for(i in 1:reps){ # start loop
Y=b0+b1*X+rnorm(n,mean=0,sd=0.7) # true dgp with standard normal errors
modelOLS=lm(Y~X) # estimate ols model
vcv=vcov(modelOLS) # obtain estimated variance-covariance matrix
par.est0.7[i,1]=modelOLS$coef[1] # store estimate of b0
par.est0.7[i,2]=modelOLS$coef[2] # store estimate of b1
par.est0.7[i,3]=sqrt(diag(vcv)[1]) # store estimated standard error of b0
par.est0.7[i,4]=sqrt(diag(vcv)[2]) # store estimated standard error of b1
} # close loop
for(i in 1:reps){ # start loop
Y=b0+b1*X+rnorm(n,mean=0,sd=0.8) # true dgp with standard normal errors
modelOLS=lm(Y~X) # estimate ols model
vcv=vcov(modelOLS) # obtain estimated variance-covariance matrix
par.est0.8[i,1]=modelOLS$coef[1] # store estimate of b0
par.est0.8[i,2]=modelOLS$coef[2] # store estimate of b1
par.est0.8[i,3]=sqrt(diag(vcv)[1]) # store estimated standard error of b0
par.est0.8[i,4]=sqrt(diag(vcv)[2]) # store estimated standard error of b1
} # close loop
for(i in 1:reps){ # start loop
Y=b0+b1*X+rnorm(n,mean=0,sd=0.9) # true dgp with standard normal errors
modelOLS=lm(Y~X) # estimate ols model
vcv=vcov(modelOLS) # obtain estimated variance-covariance matrix
par.est0.9[i,1]=modelOLS$coef[1] # store estimate of b0
par.est0.9[i,2]=modelOLS$coef[2] # store estimate of b1
par.est0.9[i,3]=sqrt(diag(vcv)[1]) # store estimated standard error of b0
par.est0.9[i,4]=sqrt(diag(vcv)[2]) # store estimated standard error of b1
} # close loop
for(i in 1:reps){ # start loop
Y=b0+b1*X+rnorm(n,mean=0,sd=1)
modelOLS10=lm(Y~X) # estimate ols model
vcv=vcov(modelOLS) # obtain estimated variance-covariance matrix
par.est1[i,1]=modelOLS$coef[1]
par.est1[i,2]=modelOLS$coef[2]
par.est1[i,3]=sqrt(diag(vcv)[1])
par.est1[i,4]=sqrt(diag(vcv)[2])
} # close loop
plot(par.est0[,2],par.est1[,2],col="darkred")
modelOLS1
modelOLS10
View(modelOLS1)
View(modelOLS1)
View(modelOLS1)
rowNames = matrix("0", nrow = ncol(dependentVariables)+1, ncol= 1, byrow = TRUE)
for (i in 1:nrow(weightVector)) {
rowNames[i, ] = paste("w", i-1, sep="")
}
rownames(weightVector)=c(rowNames)
weightVector
